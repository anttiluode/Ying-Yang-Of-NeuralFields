<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Simulation: The Yin-Yang of Neural Fields (v8 - Realistic Coupling)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1,
        h2 {
            text-align: center;
            color: #FF9800;
        }

        #warning-banner {
            background-color: #5d0000;
            color: #f0f0f0;
            border: 2px solid #ff8a80;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 8px;
            text-align: center;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }

        #container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            max-width: 1200px;
        }

        #simulation-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #controls-panel {
            background-color: #1E1E1E;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        canvas {
            border: 2px solid #FF9800;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
        }

        button {
            background-color: #FF9800;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            background-color: #fb8c00;
        }

        .param-value {
            float: right;
            color: #a0a0a0;
        }

        .explanation {
            background-color: #1E1E1E;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .explanation h3 {
            color: #FF9800;
            margin-top: 0;
        }
    </style>
</head>

<body>

    <h1>Live Simulation: The Yin-Yang of Neural Fields (v8)</h1>

    <div id="warning-banner">
        <strong>Photosensitivity Warning:</strong> This simulation generates dynamic visual patterns and flashing
        effects that may trigger seizures in individuals with photosensitive epilepsy. Please exercise caution.
    </div>

    <div id="container">
        <div id="simulation-panel">
            <h2>The Computational Field</h2>
            <canvas id="mainCanvas" width="512" height="512"></canvas>
        </div>
        <div id="controls-panel">
            <h2>Controls</h2>

            <div class="control-group">
                <label for="simulationSpeed">Simulation Speed <span class="param-value"
                        id="simulationSpeedValue">1.00</span></label>
                <input type="range" id="simulationSpeed" min="0" max="1.0" step="0.01" value="1.0">
            </div>
            <div class="control-group">
                <label for="adaptationStrength">Spike Adaptation (Stability) <span class="param-value"
                        id="adaptationStrengthValue">0.250</span></label>
                <input type="range" id="adaptationStrength" min="0" max="1.0" step="0.01" value="0.25">
            </div>
            <div class="control-group">
                <label for="baselineCurrent">Baseline Activity <span class="param-value"
                        id="baselineCurrentValue">0.030</span></label>
                <input type="range" id="baselineCurrent" min="0" max="0.1" step="0.001" value="0.03">
            </div>
            <div class="control-group">
                <label for="noiseStrength">Noise Sea (Yang Force) <span class="param-value"
                        id="noiseStrengthValue">0.15</span></label>
                <input type="range" id="noiseStrength" min="0" max="0.5" step="0.01" value="0.15">
            </div>
            <div class="control-group">
                <label for="fieldCoupling">Field Influence (Yin Force) <span class="param-value"
                        id="fieldCouplingValue">2.0</span></label>
                <input type="range" id="fieldCoupling" min="0" max="15" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label for="fieldDiffusion">Field Smoothing (Coherence) <span class="param-value"
                        id="fieldDiffusionValue">1.2</span></label>
                <input type="range" id="fieldDiffusion" min="0" max="2" step="0.05" value="1.2">
            </div>
            <div class="control-group">
                <label for="fieldDecay">Field Decay (Forgetting) <span class="param-value"
                        id="fieldDecayValue">0.04</span></label>
                <input type="range" id="fieldDecay" min="0.001" max="0.1" step="0.001" value="0.04">
            </div>
            <button id="resetButton">Reset Simulation</button>
            <button id="exportButton">Export State as JSON</button>
        </div>
    </div>

    <div class="explanation">
        <h3>What You Are Watching (v8)</h3>
        <p><strong>NEW (Realism Update):</strong> Based on the work of Pinotsis & Miller (2023), the ephaptic coupling
            model has been updated. Previously, neurons were influenced by the raw <strong>strength</strong> of the
            field. Now, they are influenced by the field's <strong>curvature</strong> (its second spatial derivative),
            referred to as the "activating function" in the paper. This means that the sharpest edges and peaks of the
            field now exert the strongest force, a more physically plausible mechanism for how electric fields influence
            neural activity.</p>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 128;
        const cellSize = canvas.width / gridSize;

        let params = {};

        let membranePotentials = new Float32Array(gridSize * gridSize);
        let firingThresholds = new Float32Array(gridSize * gridSize);
        let field = new Float32Array(gridSize * gridSize);
        let tempField = new Float32Array(gridSize * gridSize);

        let simulationTimeoutId = null; // To control the game loop

        function initialize() {
            for (let i = 0; i < gridSize * gridSize; i++) {
                membranePotentials[i] = Math.random();
                field[i] = 0;
                firingThresholds[i] = params.baseThreshold;
            }
        }

        function updateField() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const i = y * gridSize + x;
                    // Use a 9-point stencil for diffusion
                    let nSum = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx; const ny = y + dy;
                            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) { nSum += field[ny * gridSize + nx]; }
                        }
                    }
                    const dVal = (nSum / 9.0) * params.fieldDiffusion + field[i] * (1.0 - params.fieldDiffusion);
                    tempField[i] = dVal * (1 - params.fieldDecay);
                }
            }
            field.set(tempField);
        }

        function updateNeurons() {
            const isFiringArr = new Array(gridSize * gridSize).fill(false);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const i = y * gridSize + x;

                    // --- REALISTIC EPHAPTIC COUPLING (v8) ---
                    // Calculate the Laplacian (second spatial derivative) of the field
                    // This approximates the field's curvature
                    const north = (y > 0) ? field[i - gridSize] : 0;
                    const south = (y < gridSize - 1) ? field[i + gridSize] : 0;
                    const east = (x < gridSize - 1) ? field[i + 1] : 0;
                    const west = (x > 0) ? field[i - 1] : 0;
                    const laplacian = (north + south + east + west) - 4 * field[i];

                    const leak = -(membranePotentials[i] - params.vRest) / params.tau_m;
                    // The field input is now proportional to the Laplacian
                    const fInput = params.fieldCoupling * laplacian;
                    const nInput = (Math.random() - 0.5) * params.noiseStrength;

                    membranePotentials[i] += leak + fInput + nInput + params.baselineCurrent;

                    if (membranePotentials[i] > firingThresholds[i]) {
                        isFiringArr[i] = true;
                        membranePotentials[i] = params.vReset;
                        field[i] += params.spikeStrength;
                        firingThresholds[i] += params.adaptationStrength;
                    }
                    firingThresholds[i] += (params.baseThreshold - firingThresholds[i]) / params.tau_thresh;
                }
            }
            return isFiringArr;
        }

        function draw(isFiringArr) {
            const imgData = ctx.createImageData(canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < gridSize * gridSize; i++) {
                const f = Math.min(1, Math.max(0, field[i] / 2.0));
                const rb = 255 * (f > 0.5 ? (f - 0.5) * 2 : 0);
                const gb = 255 * (f > 0.25 ? Math.sin((f - 0.25) * Math.PI * 2 / 1.5) : 0);
                const bb = 255 * (f < 0.5 ? Math.sin(f * Math.PI) : 0);
                let rf = rb, gf = gb, bf = bb;
                if (isFiringArr[i]) {
                    const blend = 0.8;
                    rf = rb + (255 - rb) * blend; gf = gb + (255 - gb) * blend; bf = bb + (255 - bb) * blend;
                }
                const y = Math.floor(i / gridSize); const x = i % gridSize;
                for (let py = 0; py < cellSize; py++) {
                    for (let px = 0; px < cellSize; px++) {
                        const idx = ((y * cellSize + py) * canvas.width + (x * cellSize + px)) * 4;
                        data[idx] = rf; data[idx + 1] = gf; data[idx + 2] = bf; data[idx + 3] = 255;
                    }
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        function gameLoop() {
            // 1. Update the simulation state (physics)
            updateField();
            const isFiringArray = updateNeurons();

            // 2. Render the current state
            draw(isFiringArray);

            // 3. Schedule the next frame
            clearTimeout(simulationTimeoutId); // Ensure no duplicate loops are running
            const baseInterval = 16; // Target ~60fps
            if (params.simulationSpeed > 0.001) { // Use epsilon to avoid issues with float precision
                const interval = baseInterval / params.simulationSpeed;
                simulationTimeoutId = setTimeout(gameLoop, interval);
            }
        }

        function setupControls() {
            const allParams = {
                simulationSpeed: 1.0, adaptationStrength: 0.25, baselineCurrent: 0.03,
                noiseStrength: 0.15, fieldCoupling: 2.0, fieldDiffusion: 1.2,
                fieldDecay: 0.04, spikeStrength: 2.0, baseThreshold: 1.0, vReset: 0.0,
                vRest: 0.0, tau_m: 10, tau_thresh: 100,
            };
            Object.assign(params, allParams);

            const controlIds = ['simulationSpeed', 'adaptationStrength', 'baselineCurrent', 'noiseStrength', 'fieldCoupling', 'fieldDiffusion', 'fieldDecay'];
            controlIds.forEach(id => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(id + 'Value');
                const decimalPlaces = (id === 'fieldCoupling' || id === 'simulationSpeed' || id === 'noiseStrength' || id === 'fieldDiffusion' || id === 'fieldDecay') ? 2 : 3;
                valueSpan.textContent = parseFloat(slider.value).toFixed(decimalPlaces);

                slider.addEventListener('input', (e) => {
                    const wasPaused = params.simulationSpeed <= 0.001;
                    params[id] = parseFloat(e.target.value);
                    valueSpan.textContent = parseFloat(e.target.value).toFixed(decimalPlaces);

                    // If the speed slider is adjusted, we need to restart the loop correctly
                    if (id === 'simulationSpeed') {
                        clearTimeout(simulationTimeoutId);
                        const isPaused = params.simulationSpeed <= 0.001;
                        if ((wasPaused && !isPaused) || !isPaused) {
                            gameLoop();
                        }
                    }
                });
            });

            document.getElementById('resetButton').addEventListener('click', () => {
                initialize();
                if (params.simulationSpeed > 0.001) {
                    clearTimeout(simulationTimeoutId);
                    gameLoop();
                }
            });

            document.getElementById('exportButton').addEventListener('click', () => {
                const state = { params, membranePotentials: Array.from(membranePotentials), firingThresholds: Array.from(firingThresholds), field: Array.from(field) };
                const blob = new Blob([JSON.stringify(state)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'simulation_state.json';
                a.click();
                URL.revokeObjectURL(url);
            });
        };

        // --- Start the simulation ---
        setupControls();
        initialize();
        gameLoop(); // Initial call to start the loop

    </script>

</body>

</html>